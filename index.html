<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生日快乐 - 清芳宝宝</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'Courier New', Courier, monospace;
            user-select: none; /* 禁止选中文字 */
        }

        canvas {
            display: block;
            z-index: 1;
        }

        /* 界面UI层 */
        .ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            pointer-events: none; /* 让鼠标穿透文字操作Canvas */
            mix-blend-mode: screen; /* 混合模式让文字更透亮 */
        }

        h1 {
            font-size: 5rem;
            margin: 0;
            color: #fff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff;
            animation: pulse 2s infinite alternate;
        }

        h2 {
            font-size: 1.5rem;
            color: #ff00de;
            letter-spacing: 5px;
            margin-top: 10px;
            text-shadow: 0 0 5px #ff00de;
        }

        .tips {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            z-index: 10;
            pointer-events: none;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 10px #0ff, 0 0 20px #0ff; transform: scale(1); }
            100% { text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #0ff; transform: scale(1.02); }
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            h1 { font-size: 3rem; }
            h2 { font-size: 1rem; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <h1 id="name-title">清芳宝宝</h1>
        <h2 id="sub-title">生日快乐</h2>
    </div>

    <div class="tips">
        [ 按住鼠标：吸引粒子 ] &nbsp;&nbsp; [ 松开/点击：引力爆炸 ]
    </div>

    <script>
        // --- 1. 配置区域 ---
        const config = {
            particleCount: 120,    // 粒子数量 (太多会卡)
            mouseRange: 200,       // 鼠标感应范围
            colors: [
                '#00ffff', // 青色
                '#ff00de', // 洋红
                '#ffff00', // 黄色
                '#00ff00'  // 亮绿
            ] 
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // 鼠标状态
        const mouse = { x: -1000, y: -1000, isDown: false };

        // --- 2. 物理工具函数 ---
        function random(min, max) { return Math.random() * (max - min) + min; }
        function getDistance(x1, y1, x2, y2) { return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)); }

        // 旋转向量 (用于处理弹性碰撞)
        function rotate(velocity, angle) {
            return {
                x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
                y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
            };
        }

        // 处理粒子间的弹性碰撞
        function resolveCollision(particle, otherParticle) {
            const xVelocityDiff = particle.velocity.x - otherParticle.velocity.x;
            const yVelocityDiff = particle.velocity.y - otherParticle.velocity.y;

            const xDist = otherParticle.x - particle.x;
            const yDist = otherParticle.y - particle.y;

            // 只有正在靠近时才处理碰撞 (防止粘连)
            if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {
                const angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);

                const m1 = particle.mass;
                const m2 = otherParticle.mass;

                const u1 = rotate(particle.velocity, angle);
                const u2 = rotate(otherParticle.velocity, angle);

                const v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };
                const v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m1 / (m1 + m2), y: u2.y };

                const vFinal1 = rotate(v1, -angle);
                const vFinal2 = rotate(v2, -angle);

                particle.velocity.x = vFinal1.x;
                particle.velocity.y = vFinal1.y;
                otherParticle.velocity.x = vFinal2.x;
                otherParticle.velocity.y = vFinal2.y;
            }
        }

        // --- 3. 粒子类 ---
        class Particle {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.velocity = {
                    x: (Math.random() - 0.5) * 4,
                    y: (Math.random() - 0.5) * 4
                };
                this.radius = radius;
                this.color = color;
                this.mass = 1; // 质量设为1
                this.opacity = 0;
            }

            update(particles) {
                // 绘制
                this.draw();

                // 碰撞检测 (粒子与粒子)
                for (let i = 0; i < particles.length; i++) {
                    if (this === particles[i]) continue;
                    if (getDistance(this.x, this.y, particles[i].x, particles[i].y) - this.radius * 2 < 0) {
                        resolveCollision(this, particles[i]);
                    }
                }

                // 边界检测 (碰到墙壁反弹)
                if (this.x - this.radius <= 0 || this.x + this.radius >= width) {
                    this.velocity.x = -this.velocity.x;
                }
                if (this.y - this.radius <= 0 || this.y + this.radius >= height) {
                    this.velocity.y = -this.velocity.y;
                }

                // 鼠标交互物理
                // 如果鼠标按下：产生强引力（黑洞效果）
                // 如果鼠标松开：正常移动
                const distToMouse = getDistance(this.x, this.y, mouse.x, mouse.y);
                
                if (mouse.isDown) {
                    // 引力模式
                    const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                    const force = 0.5; // 引力强度
                    this.velocity.x += Math.cos(angle) * force;
                    this.velocity.y += Math.sin(angle) * force;
                    
                    // 增加阻力防止过快
                    this.velocity.x *= 0.95;
                    this.velocity.y *= 0.95;
                } else {
                    // 斥力模式 (当鼠标仅仅是移动经过时，稍微推开一点，增加互动感)
                    if (distToMouse < 100) {
                        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                        this.velocity.x -= Math.cos(angle) * 0.5;
                        this.velocity.y -= Math.sin(angle) * 0.5;
                    }
                }

                // 应用速度
                this.x += this.velocity.x;
                this.y += this.velocity.y;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = this.color;
                // 添加霓虹发光效果
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.restore();
                ctx.closePath();
            }
        }

        // --- 4. 初始化与动画循环 ---
        let particles = [];
        
        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            particles = [];

            for (let i = 0; i < config.particleCount; i++) {
                const radius = random(5, 12); // 随机大小
                let x = random(radius, width - radius);
                let y = random(radius, height - radius);
                const color = config.colors[Math.floor(Math.random() * config.colors.length)];
                
                // 防止生成时重叠
                if (i !== 0) {
                    for (let j = 0; j < particles.length; j++) {
                        if (getDistance(x, y, particles[j].x, particles[j].y) - radius * 2 < 0) {
                            x = random(radius, width - radius);
                            y = random(radius, height - radius);
                            j = -1;
                        }
                    }
                }
                particles.push(new Particle(x, y, radius, color));
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            // 制造拖尾效果
            ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; 
            ctx.fillRect(0, 0, width, height);

            particles.forEach(particle => {
                particle.update(particles);
            });
        }

        // --- 5. 事件监听 ---
        window.addEventListener('resize', () => {
            init();
        });

        // 鼠标移动
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // 鼠标按下 - 开启黑洞引力
        window.addEventListener('mousedown', () => {
            mouse.isDown = true;
        });

        // 鼠标松开 - 产生斥力爆炸
        window.addEventListener('mouseup', () => {
            mouse.isDown = false;
            // 松开瞬间给所有附近粒子一个向外的爆发力
            particles.forEach(p => {
                const dist = getDistance(p.x, p.y, mouse.x, mouse.y);
                if (dist < 400) {
                    const angle = Math.atan2(p.y - mouse.y, p.x - mouse.x); // 向外
                    const force = (400 - dist) * 0.1; // 距离越近力越大
                    p.velocity.x += Math.cos(angle) * force;
                    p.velocity.y += Math.sin(angle) * force;
                }
            });
        });

        // 触摸屏支持
        window.addEventListener('touchstart', (e) => {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            mouse.isDown = true;
        });
        window.addEventListener('touchend', () => {
            mouse.isDown = false;
        });

        // 启动
        init();
        animate();

    </script>
</body>
</html>
